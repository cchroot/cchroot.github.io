<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="vue.js,">










<meta name="description" content="这篇文章的优化内容是建立在 webpack 4.x 上的，后面也会有 webpack 5.x 相关的介绍 优化方式总览加快构建速度(打包速度) 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainF">
<meta name="keywords" content="vue.js">
<meta property="og:type" content="article">
<meta property="og:title" content="Webpack 性能优化">
<meta property="og:url" content="http://yoursite.com/2020/12/26/Webpack 性能优化/index.html">
<meta property="og:site_name" content="cchroot&#39;s blog">
<meta property="og:description" content="这篇文章的优化内容是建立在 webpack 4.x 上的，后面也会有 webpack 5.x 相关的介绍 优化方式总览加快构建速度(打包速度) 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainF">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/webpack/source_map_1.png">
<meta property="og:updated_time" content="2021-01-24T12:50:19.003Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Webpack 性能优化">
<meta name="twitter:description" content="这篇文章的优化内容是建立在 webpack 4.x 上的，后面也会有 webpack 5.x 相关的介绍 优化方式总览加快构建速度(打包速度) 使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果  缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainF">
<meta name="twitter:image" content="http://yoursite.com/images/webpack/source_map_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/12/26/Webpack 性能优化/">





  <title>Webpack 性能优化 | cchroot's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cchroot's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            文章树
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-navicon"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bullseye"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-javascript">
          <a href="/categories/javascript/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br>
            
            javascript
          </a>
        </li>
      
        
        <li class="menu-item menu-item-vue">
          <a href="/categories/vueJs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-get-pocket"></i> <br>
            
            vue.js
          </a>
        </li>
      
        
        <li class="menu-item menu-item-react">
          <a href="/categories/reactJs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-asterisk"></i> <br>
            
            react.js
          </a>
        </li>
      
        
        <li class="menu-item menu-item-node">
          <a href="/categories/nodeJs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-adjust"></i> <br>
            
            node.js
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/categories/java/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br>
            
            java
          </a>
        </li>
      
        
        <li class="menu-item menu-item-linux">
          <a href="/categories/linux/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-circle"></i> <br>
            
            linux
          </a>
        </li>
      
        
        <li class="menu-item menu-item-arithmetic">
          <a href="/categories/arithmetic/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br>
            
            arithmetic
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tools">
          <a href="/categories/tool/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-wrench"></i> <br>
            
            tool
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/26/Webpack 性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cchroot">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/headPhoto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cchroot's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Webpack 性能优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-26T20:37:05+08:00">
                2020-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vueJs/" itemprop="url" rel="index">
                    <span itemprop="name">vueJs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇文章的优化内容是建立在 webpack 4.x 上的，后面也会有 webpack 5.x 相关的介绍</p>
<h2 id="优化方式总览"><a href="#优化方式总览" class="headerlink" title="优化方式总览"></a>优化方式总览</h2><p><strong>加快构建速度(打包速度)</strong></p>
<p>使用 speed-measure-webpack-plugin 插件可以测量各个插件和loader所花费的时间，量化打包速度，判断优化效果</p>
<ol>
<li>缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)<ol>
<li>通过 exclude、include 配置来确保转译尽可能少的文件</li>
<li>优化 resolve.modules 配置</li>
<li>优化 resolve.mainFields 配置</li>
<li>alias</li>
<li>noParse</li>
<li>extensions</li>
</ol>
</li>
<li>在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中</li>
<li>使用 happypack 开启多进程打包</li>
<li>除了使用 Happypack 外，我们也可以使用 thread-loader 开启多进程打包 loader</li>
<li>使用 HardSourceWebpackPlugin 为模块提供中间缓存，第二次构建可大量节约时间</li>
<li>使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包</li>
<li>使用 webpack-parallel-uglify-plugin 开启 JS 多进程压缩</li>
</ol>
<p><strong>减少打包文件体积</strong></p>
<p>引入 webpack-bundle-analyzer 分析打包后的文件，判断哪些包还可以拆分和优化</p>
<ol>
<li>使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN</li>
<li>使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间</li>
<li>使用 optimization.splitChunks 配置抽离公共代码</li>
<li>使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）</li>
<li>使用 url-loader 或 image-webpack-loader 对图片进行转化或者压缩处理</li>
<li>优化 SourceMap，开发环境推荐： cheap-module-eval-source-map，生产环境推荐： cheap-module-source-map</li>
<li>按需加载，项目中的路由懒加载 </li>
<li>webpack自身的优化：<ol>
<li>tree-shaking，在生产环境下，会自动移除没有使用到的代码</li>
<li>scope hosting 作用域提升，变量提升，可以减少一些变量声明</li>
<li>babel 配置的优化，配置 @babel/plugin-transform-runtime，重复使用 Babel 注入的帮助程序，以节省代码大小的插件。</li>
</ol>
</li>
</ol>
<h2 id="加快-Webpack-构建速度-打包速度"><a href="#加快-Webpack-构建速度-打包速度" class="headerlink" title="加快 Webpack 构建速度(打包速度)"></a>加快 Webpack 构建速度(打包速度)</h2><h3 id="使用-speed-measure-webpack-plugin-插件测量打包速度"><a href="#使用-speed-measure-webpack-plugin-插件测量打包速度" class="headerlink" title="使用 speed-measure-webpack-plugin 插件测量打包速度"></a>使用 speed-measure-webpack-plugin 插件测量打包速度</h3><p>使用 speed-measure-webpack-plugin 插件可以测量各个插件和 loader 所花费的时间，量化打包速度，对比前后的信息，判断优化效果。</p>
<p>使用方式很简单，可以直接用其来包裹 Webpack 的配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">"speed-measure-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">//...webpack配置，不用在写 module.exports</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smp.wrap(config);</span><br></pre></td></tr></table></figure>
<h3 id="1-缩小文件的搜索范围-配置include-exclude-resolve-modules-resolve-mainFields-alias-noParse-extensions"><a href="#1-缩小文件的搜索范围-配置include-exclude-resolve-modules-resolve-mainFields-alias-noParse-extensions" class="headerlink" title="1.缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)"></a>1.缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)</h3><h4 id="exclude-include"><a href="#exclude-include" class="headerlink" title="exclude/include"></a>exclude/include</h4><p>在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。</p>
<p>exclude 指定要排除的文件，include 指定要包含的文件。exclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组，尽量避免 exclude，更倾向于使用 include。</p>
<p>例如在配置 babel-loader 时，可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">        use: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化-resolve-modules-配置"><a href="#优化-resolve-modules-配置" class="headerlink" title="优化 resolve.modules 配置"></a>优化 resolve.modules 配置</h4><p>使用 resolve 配置 webpack 去哪些目录下寻找第三方模块</p>
<p>当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">  <span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line">  <span class="comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span></span><br><span class="line">     modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化-resolve-mainFields-配置"><a href="#优化-resolve-mainFields-配置" class="headerlink" title="优化 resolve.mainFields 配置"></a>优化 resolve.mainFields 配置</h4><p>resolve.mainFields 用于配置第三方模块使用哪个入口文件</p>
<p>为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 或 index 字段去描述入口文件的位置，可以这样配置 Webpack：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 采用 main 或 index 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">    mainFields: [<span class="string">'main'</span>, <span class="string">'index'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个配置一般很较少用，要注意所有第三方模块的入口文件。</p>
<h4 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h4><p>resolve.alias 配置项以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径。</p>
<p>例如使用以下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Webpack alias 配置</span></span><br><span class="line">resolve:&#123;</span><br><span class="line">  alias:&#123;</span><br><span class="line">    components: <span class="string">'./src/components/'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你通过 import Button from ‘components/button’ 导入时，实际上被 alias 等价替换成了 import Button from ‘./src/components/button’。</p>
<p>默认情况下 Webpack 会从入口文件 <code>./node_modules/react/react.js</code> 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件，</span></span><br><span class="line">    <span class="comment">// 减少耗时的递归解析操作</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/dist/react.min.js'</span>), <span class="comment">// react15</span></span><br><span class="line">      <span class="comment">// 'react': path.resolve(__dirname, './node_modules/react/umd/react.production.min.js'), // react16</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。</p>
<p>但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking 去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。 一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。 但是对于一些工具类的库，例如 lodash，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。</p>
<p>alias 还支持 $ 符号来缩小范围到只命中以关键字结尾的导入语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">  alias:&#123;</span><br><span class="line">    <span class="string">'react$'</span>: <span class="string">'/path/to/react.min.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>react$ 只会命中以 react 结尾的导入语句，即只会把 import ‘react’ 关键字替换成 import ‘/path/to/react.min.js’。</p>
<h4 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h4><p>如果一些第三方模块没有 AMD/CommonJS 规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。</p>
<p>在上面的 优化 resolve.alias 配置 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理</span></span><br><span class="line">	<span class="comment">// noParse 属性的值是一个正则表达式或者是一个 function</span></span><br><span class="line">    noParse: [<span class="regexp">/react\.min\.js$/</span>] <span class="comment">// /jquery|lodash/</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h4><p>webpack 会根据 extensions 定义的后缀查找文件(频率较高的文件类型优先写在前面)，<br>默认是 <code>extensions: [&#39;.js&#39;, &#39;.json&#39;]</code></p>
<p>也就是说当遇到 require(‘./data’) 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。</p>
<p>如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能：</p>
<ul>
<li><p>后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中</p>
</li>
<li><p>频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程</p>
</li>
<li><p>在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require(‘./data’) 写成 require(‘./data.json’)</p>
</li>
</ul>
<p>Webpack 配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 尽可能的减少后缀尝试的可能性</span></span><br><span class="line">    extensions: [<span class="string">'js'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-cache-loader，将结果缓存中磁盘中"><a href="#2-使用-cache-loader，将结果缓存中磁盘中" class="headerlink" title="2.使用 cache-loader，将结果缓存中磁盘中"></a>2.使用 cache-loader，将结果缓存中磁盘中</h3><p>在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 <code>node_modueles/.cache/cache-loader</code> 目录下。它所做的事情很简单，就是 babel-loader 开启 cache 后做的事情，将 loader 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cache-loader -D</span><br></pre></td></tr></table></figure>
<p>cache-loader 的配置很简单，放在其他 loader 之前即可。修改Webpack 的配置如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 例如 babel-loader 耗时比较长，给它配置 cache-loader 放在 loader 之前</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: [<span class="string">'cache-loader'</span>,<span class="string">'babel-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只打算给 babel-loader 配置 cache 的话，也可以不使用 cache-loader，给 babel-loader 增加选项 cacheDirectory。</p>
<p>cacheDirectory：默认值为 false。当设置为 true 时，指定的目录将用来缓存 loader 的执行结果。之后的 Webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。使用默认缓存目录：<code>node_modules/.cache/babel-loader</code>。</p>
<p>使用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用-happypack-开启多进程打包"><a href="#3-使用-happypack-开启多进程打包" class="headerlink" title="3.使用 happypack 开启多进程打包"></a>3.使用 happypack 开启多进程打包</h3><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，解析转换以及代码的压缩中的时间很长，这样就会导致构建时间变长。</p>
<p>HappyPack 的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间:</p>
<p>安装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i happypack -D</span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Happypack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js[x]?$/</span>,</span><br><span class="line">        use: <span class="string">'Happypack/loader?id=js'</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: <span class="string">'Happypack/loader?id=css'</span>,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">          path.resolve(__dirname, <span class="string">'node_modules'</span>, <span class="string">'bootstrap'</span>, <span class="string">'dist'</span>)</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Happypack(&#123;</span><br><span class="line">      id: <span class="string">'js'</span>, <span class="comment">// 和rule中的 id=js 对应</span></span><br><span class="line">      <span class="comment">// 将之前 rule 中的 loader 删除，在此配置</span></span><br><span class="line">      use: [<span class="string">'babel-loader'</span>] <span class="comment">//必须是数组</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> Happypack(&#123;</span><br><span class="line">      id: <span class="string">'css'</span>,<span class="comment">// 和rule中的 id=css 对应</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>,<span class="string">'postcss-loader'</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-thread-loader"><a href="#4-thread-loader" class="headerlink" title="4.thread-loader"></a>4.thread-loader</h3><p>除了使用 Happypack 外，我们也可以使用 thread-loader ，把 thread-loader 放置在其它 loader 之前，那么放置在这个 loader 之后的 loader 就会在一个单独的 worker 池中运行。</p>
<p>在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：</p>
<ul>
<li><p>这些 loader 不能产生新的文件。</p>
</li>
<li><p>这些 loader 不能使用定制的 loader API（也就是说，通过插件）。</p>
</li>
<li><p>这些 loader 无法获取 webpack 的选项设置。</p>
</li>
</ul>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 配置 thread-loader 放在所有 loader 之前（包括 cache-loader）</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: [<span class="string">'thread-loader'</span>, <span class="string">'cache-loader'</span>, <span class="string">'babel-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-使用-hard-source-webpack-plugin-为模块提供中间缓存"><a href="#5-使用-hard-source-webpack-plugin-为模块提供中间缓存" class="headerlink" title="5.使用 hard-source-webpack-plugin 为模块提供中间缓存"></a>5.使用 hard-source-webpack-plugin 为模块提供中间缓存</h3><p>HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。</p>
<p>配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。</p>
<p>安装依赖:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hard-source-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>修改配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 hard-source-webpack-plugin 存在一些坑，如果遇到某些配置不生效了，例如热更新失效，或者某些配置不生效等，可以查看<a href="https://www.npmjs.com/package/hard-source-webpack-plugin" target="_blank" rel="noopener">HardSourceWebpackPlugin文档</a> ，文档中列出了一些你可能会遇到的问题以及如何解决。    </p>
<h3 id="6-使用-IgnorePlugin-忽略第三方包指定目录"><a href="#6-使用-IgnorePlugin-忽略第三方包指定目录" class="headerlink" title="6.使用 IgnorePlugin 忽略第三方包指定目录"></a>6.使用 IgnorePlugin 忽略第三方包指定目录</h3><p>IgnorePlugin 是 webpack 的内置插件，作用是忽略第三方包指定目录。例如: moment (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnorePlugin 在打包时忽略本地化内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 忽略 moment 下的 ./locale 目录</span></span><br><span class="line">    <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略 moment 下的 ./locale 目录后，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span>;<span class="comment">// 手动引入自己需要的语言包</span></span><br></pre></td></tr></table></figure>
<p>index.js 中只引入 moment，打包出来的 bundle.js 大小和配置了 IgnorePlugin，单独引入 <code>moment/locale/zh-cn</code>，构建出来的包大小为大概差距有 200k 左右。</p>
<h3 id="7-关于使用-webpack-parallel-uglify-plugin-增强代码压缩"><a href="#7-关于使用-webpack-parallel-uglify-plugin-增强代码压缩" class="headerlink" title="7.关于使用 webpack-parallel-uglify-plugin 增强代码压缩"></a>7.关于使用 webpack-parallel-uglify-plugin 增强代码压缩</h3><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。</p>
<p>但是在 webpack4.x 内置默认使用 TerserWebpackPlugin，在 mode 设置为 production 就会默认开启 TerserWebpackPlugin，所以可以不用配置 webpack-parallel-uglify-plugin</p>
<h2 id="减少打包文件体积"><a href="#减少打包文件体积" class="headerlink" title="减少打包文件体积"></a>减少打包文件体积</h2><h3 id="引入-webpack-bundle-analyzer-分析打包后的文件"><a href="#引入-webpack-bundle-analyzer-分析打包后的文件" class="headerlink" title="引入 webpack-bundle-analyzer 分析打包后的文件"></a>引入 webpack-bundle-analyzer 分析打包后的文件</h3><p>借助 webpack-bundle-analyzer 可以分析打包后的文件，判断哪些包体积过大，是否可以拆分和优化</p>
<p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>
<p>使用也很简单，修改我们的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports =  &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">	  analyzerHost: <span class="string">'127.0.0.1'</span>, <span class="comment">// 默认这两个配置都可以不配</span></span><br><span class="line">	  analyzerPort: <span class="number">8889</span> <span class="comment">// 默认 8888</span></span><br><span class="line">	&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在 package.json 里配置启动命令 (不配置也可以，npm run build 打包时，会默认打开： <a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"analyz": "NODE_ENV=production npm_config_report=true npm run build"</span><br></pre></td></tr></table></figure></p>
<p>复制代码 windows 请安装 <code>npm i -D cross-env</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"analyz": "cross-env NODE_ENV=production npm_config_report=true npm run build"</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">复制代码接下来 npm run analyz 浏览器会自动打开文件依赖图的网页</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 1.使用 externals 配置，然后将 JS 文件、CSS 文件和存储在 CDN</span></span></span><br><span class="line"></span><br><span class="line">如果我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 Externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 Externals 的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 CDN 的方式，去引用它们。</span><br><span class="line"></span><br><span class="line">官方案例:</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;script src="https://code.jquery.com/jquery-3.1.0.js"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">'jQuery'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意，’:’ 号后面对应的文件名必须和项目里面 import 引入的文件昵称相同，例如： import Vue from 'vue' 就是上面对应的 'vue': 'Vue'。</span></span><br><span class="line"><span class="comment">// 这里特别注意一下 element-ui 的昵称必须是: ‘ELEMENT’, 如果使用其它昵称将报错。具体看 element-ui 源码导出方式你就懂了~</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目中也可以正常 import</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line">$(<span class="string">'.my-element'</span>).animate(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>
<p>在项目中经常把各种库文件使用 CDN 加载，然后通过 html-webpack-plugin 插入到模板页面中。</p>
<h3 id="2-使用-DllPlugin（动态链接库）将-bundles-拆分"><a href="#2-使用-DllPlugin（动态链接库）将-bundles-拆分" class="headerlink" title="2.使用 DllPlugin（动态链接库）将 bundles 拆分"></a>2.使用 DllPlugin（动态链接库）将 bundles 拆分</h3><p>有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 bundles。</p>
<p>使用 DllPlugin（动态链接库）将 bundles 拆分，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码和不会频繁更新的库先打包成静态资源，避免反复编译浪费时间。例如我们将 react 和 react-dom 单独打包成一个动态链接库：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].dll.[hash:6].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>),</span><br><span class="line">    library: <span class="string">'[name]_dll'</span> <span class="comment">// 暴露给外部使用</span></span><br><span class="line">    <span class="comment">// libraryTarget 指定如何暴露内容，缺省时就是 var</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// name 和 library一致</span></span><br><span class="line">      name: <span class="string">'[name]_dll'</span>, </span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">'manifest.json'</span>) <span class="comment">//manifest.json 的生成路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-optimization-splitChunks-配置抽离公共代码"><a href="#3-使用-optimization-splitChunks-配置抽离公共代码" class="headerlink" title="3.使用 optimization.splitChunks 配置抽离公共代码"></a>3.使用 optimization.splitChunks 配置抽离公共代码</h3><p>抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。</p>
<p>抽离公共代码是 webpack 内置的，在 optimization.splitChunks 中配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;<span class="comment">// 分割代码块</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          <span class="comment">// 第三方依赖</span></span><br><span class="line">          priority: <span class="number">1</span>, <span class="comment">// 设置权重，首先抽离第三方模块</span></span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minSize: <span class="number">0</span>,</span><br><span class="line">          minChunks: <span class="number">3</span> <span class="comment">//最少引入了3次</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//缓存组</span></span><br><span class="line">        common: &#123;</span><br><span class="line">          <span class="comment">// 公共模块</span></span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'common'</span>,</span><br><span class="line">          minSize: <span class="number">10</span>, <span class="comment">// 大小超过10个字节</span></span><br><span class="line">          minChunks: <span class="number">2</span> <span class="comment">// 最少引入了2次</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-使用-IgnorePlugin-忽略第三方包指定目录，例如-moment-的本地语言包（重复）"><a href="#4-使用-IgnorePlugin-忽略第三方包指定目录，例如-moment-的本地语言包（重复）" class="headerlink" title="4.使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）"></a>4.使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）</h3><p>IgnorePlugin 也有减少打包文件体积的作用，这里也列出来，但是和上加快构建速度一样，就不再重复说明</p>
<h3 id="5-使用-url-loader-和-image-webpack-loader-对图片进行转化和压缩处理"><a href="#5-使用-url-loader-和-image-webpack-loader-对图片进行转化和压缩处理" class="headerlink" title="5.使用 url-loader 和 image-webpack-loader 对图片进行转化和压缩处理"></a>5.使用 url-loader 和 image-webpack-loader 对图片进行转化和压缩处理</h3><p>如果本地图片比较多的话，采用 image-webpack-loader 压缩后，再对比较小的图片根据 url-loader 来进转化为 base64 格式，可以有效减少打包文件的体积和图片的 http 请求数量。</p>
<p>配置（注意 loader 从上到下，先右后左执行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|gif|jpe?g|svg)$/i</span>,</span><br><span class="line">    	exclude:[path.resolve(process.cwd(), <span class="string">'src/assets/css'</span>)],</span><br><span class="line">    	use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">1024</span>,</span><br><span class="line">              name: <span class="string">'[hash:8].[ext]'</span>,</span><br><span class="line">              useRelativePath: <span class="literal">false</span>,</span><br><span class="line">              outputPath: <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'assets/images/'</span>+fileName</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader:<span class="string">'image-webpack-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">    	]</span><br><span class="line">	  &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-优化-source-map"><a href="#6-优化-source-map" class="headerlink" title="6.优化 source map"></a>6.优化 source map</h3><p><strong>什么是 source map</strong>？</p>
<p>我们打包，将开发环境中的源代码经过压缩，去空格，babel 编译转化，最终可以得到适用于生产环境的代码。但这样处理后的代码和源代码之间存在很大的差异，难以阅读且无法 debug。</p>
<p>如果压缩等处理过的生产环境中的代码出现 bug，那么调试的时候只能定位到压缩处理后的代码的位置，无法定位到开发环境中源码位置。source map 就是为解决上述的代码定位问题。方便开发人员 debug，定位错误。</p>
<p>在 webpack 中提供了十几种 source map 的组合：</p>
<p><img src="/images/webpack/source_map_1.png" alt="source_map图"></p>
<p>+++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, – 慢</p>
<p>其中一些值适用于开发环境，一些适用于生产环境。对于开发环境，通常希望更快速的 source map，需要添加到 bundle 中以增加体积为代价，但是对于生产环境，则希望更精准的 source map，需要从 bundle 中分离并独立存在。</p>
<p><strong>在不同环境中如何选择 source map 的类型</strong></p>
<ol>
<li><p>首先在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系。因此，不管是开发还是生产环境都会增加 cheap 属性来忽略模块打包后的列信息关联</p>
</li>
<li><p>不管是生产环境还是开发环境，我们都需要定位 debug 到最原始的资源，比如定位错误到 jsx，ts 的原始代码，而不是经编译后的 js 代码。所以不可以忽略掉 module 属性</p>
</li>
<li><p>需要生成 .map 文件，所以得有 source-map 属性</p>
</li>
</ol>
<p>所有有:</p>
<ul>
<li><p>开发环境推荐使用：cheap-module-eval-source-map</p>
</li>
<li><p>生产环境推荐使用：cheap-module-source-map</p>
</li>
</ul>
<p>更详细的介绍请看官网：<a href="https://www.webpackjs.com/configuration/devtool/" target="_blank" rel="noopener">devtool</a></p>
<h3 id="7-按需加载，"><a href="#7-按需加载，" class="headerlink" title="7.按需加载，"></a>7.按需加载，</h3><p>在 vue 和 react 单页面项目中，我们一般会通过路由懒加载来实现按需加载，这里就不再赘述</p>
<h3 id="8-webpack4-x-后版本自身的优化："><a href="#8-webpack4-x-后版本自身的优化：" class="headerlink" title="8. webpack4.x 后版本自身的优化："></a>8. webpack4.x 后版本自身的优化：</h3><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，即会自动移除没有使用到的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">export const a = 1</span><br><span class="line">export const b = 2</span><br><span class="line">// index.js</span><br><span class="line">import &#123; a &#125; from &apos;./test.js&apos;</span><br></pre></td></tr></table></figure>
<p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。</p>
<p>如果你使用 Webpack4.x 的话，生产环境就会自动启动这个优化功能。</p>
<h4 id="scope-hosting-作用域提升，变量提升，可以减少一些变量声明"><a href="#scope-hosting-作用域提升，变量提升，可以减少一些变量声明" class="headerlink" title="scope hosting 作用域提升，变量提升，可以减少一些变量声明"></a>scope hosting 作用域提升，变量提升，可以减少一些变量声明</h4><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去，在生产环境下，默认开启。</p>
<p>比如我们希望打包两个文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们打包出来的代码会类似这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了，生产环境默认开启。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="babel-配置的优化"><a href="#babel-配置的优化" class="headerlink" title="babel 配置的优化"></a>babel 配置的优化</h4><p>配置 <code>@babel/plugin-transform-runtime</code>，重复使用 Babel 注入的帮助程序，以节省代码大小的插件。</p>
<p>在不配置 ·<code>@babel/plugin-transform-runtime</code> 时，babel 会使用很小的辅助函数来实现类似 _createClass 等公共方法。默认情况下，它将被注入(inject)到需要它的每个文件中。但是这样的结果就是导致构建出来的JS体积变大。</p>
<p>我们也并不需要在每个 js 中注入辅助函数，因此我们可以使用 <code>@babel/plugin-transform-runtime</code>，<code>@babel/plugin-transform-runtime</code> 是一个可以重复使用 Babel 注入的帮助程序，以节省代码大小的插件。</p>
<p>因此我们可以在 <code>.babelrc</code> 中增加 <code>@babel/plugin-transform-runtime</code> 的配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于-webpack-5-x"><a href="#关于-webpack-5-x" class="headerlink" title="关于 webpack 5.x"></a>关于 webpack 5.x</h2><p>虽然我们在项目中大部分童鞋可能还是使用的 4.x 版本，但是 webpack 当前最新的版本已经是 5.10.1 了，那么 5.x 版本主要更新了什么呢？</p>
<h3 id="1-剔除npm包里面针对Node-js模块自动引用的Polyfills"><a href="#1-剔除npm包里面针对Node-js模块自动引用的Polyfills" class="headerlink" title="1.剔除npm包里面针对Node.js模块自动引用的Polyfills"></a>1.剔除npm包里面针对Node.js模块自动引用的Polyfills</h3><p>Webpack 4.x 编译引入 npm 包，有些 npm 包里面包含针对 nodejs 的 polyfills，polyfill 会加到最终的 bundle 中，实际前端浏览器是不需要的，5.x 后的版本会自动剔除</p>
<p>Webpack 5.x 版本编译中，会出现 polyfill 添加提示，如果不需要 node polyfille,按照提示 alias 设置为 false 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">// 1.不需要 node polyfilss</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    crypto: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2.若需要，可以手动添加 polyfills</span></span><br><span class="line">  <span class="comment">// fallback: &#123;</span></span><br><span class="line">  <span class="comment">//   "crypto": require.resolve('crypto-browserify')</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-长期缓存优化"><a href="#2-长期缓存优化" class="headerlink" title="2.长期缓存优化"></a>2.长期缓存优化</h3><p>Webpack 4.x 是根据代码的结构生成 chunkhash，现在 5.x 根据完全内容生成 chunkhash，比如改了内容的注释或者变量则不会引起 chunkhash 的变化，让浏览器继续使用缓存：</p>
<p>Webpack 5.x 针对 moduleId 和 chunkId 的计算方式进行了优化，增加确定性的 moduleId 和 chunkId 的生成策略。moduleId 根据上下文模块路径，chunkId 根据 chunk 内容计算，最后为 moduleId 和 chunkId 生成 3 ~ 4 位的数字 id，实现长期缓存，生产环境下默认开启。</p>
<h3 id="3-持久缓存优化"><a href="#3-持久缓存优化" class="headerlink" title="3.持久缓存优化"></a>3.持久缓存优化</h3><p>在 Webpack 4.x 我们一般采用 <code>cache-loader</code> 或者 <code>babel-loader</code> 自带的 <code>cacheDirectory</code> 来进行缓存操作，在 Webpack 5.x 中缓存默认是 memory，你可以修改设置写入硬盘：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">  cache: &#123;</span><br><span class="line">    <span class="comment">// 1. 将缓存类型设置为文件系统</span></span><br><span class="line">    type: <span class="string">'filesystem'</span>, <span class="comment">// 默认是memory</span></span><br><span class="line">    <span class="comment">// 2. 将缓存文件夹命名为 .temp_cache,</span></span><br><span class="line">    <span class="comment">// 默认路径是 node_modules/.cache/webpack</span></span><br><span class="line">    cacheDirectory: path.resolve(__dirname, <span class="string">'.temp_cache'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次构建是一次全量构建，它会利用磁盘模块缓存(以空间换时间)，使得后续的构建从中获利</p>
<p>续构建具体流程是：读取磁盘缓存 -&gt; 校验模块 -&gt; 解封模块内容。</p>
<h3 id="4-更好的Tree-Shacking-构建优化"><a href="#4-更好的Tree-Shacking-构建优化" class="headerlink" title="4.更好的Tree Shacking(构建优化)"></a>4.更好的Tree Shacking(构建优化)</h3><p>现在有这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inner.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">'aaaaaaaaaa'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">'bbbbbbbbbb'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> inner <span class="keyword">from</span> <span class="string">"./inner"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; inner &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">"./module"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.inner.a);</span><br></pre></td></tr></table></figure>
<p>在 Webpack 4.x 中毫无疑问，以上代码 a、b 变量是被全部打包的。但我们只调用了 a 变量，理想情况应该是 b 被识别为 unused，不被打包。这一优化在 Webpack 5.x 中实现了。 在 Webpack 5.x 中会分析模块 export 与 import 之间的依赖关系，最终的代码生成非常简洁：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="string">"use strict"</span>;<span class="built_in">console</span>.log(<span class="string">"aaaaaaaaaa"</span>)&#125;();</span><br></pre></td></tr></table></figure>
<h3 id="5-Module-Federation-模板联邦"><a href="#5-Module-Federation-模板联邦" class="headerlink" title="5.Module Federation(模板联邦)"></a>5.Module Federation(模板联邦)</h3><p>上面 4 点优化都是对 webpack 常规优化，而 Module Federation 就是 Webpack 5.x 中的重大的变革了</p>
<p>Module Federation 让 Webpack 达到了线上 runtime 的效果，让 chunk 直接在独立应用间利用 CDN 直接共享，不再需要本地安装 NPM 包、构建再发布了</p>
<p><strong>之前我们希望共享代码是如何做的</strong>？</p>
<ul>
<li>NPM</li>
</ul>
<p>维护一个 CommonComponents 的 NPM 包，在不同项目中安装、使用。如果 NPM 包升级，对应项目都需要安装新版本，本地编译，打包到 bundle 中</p>
<ul>
<li>UMD</li>
</ul>
<p>UMD 优点在 runtime。缺点也明显，体积优化不方便，容易有版本冲突</p>
<ul>
<li>微前端</li>
</ul>
<p>独立应用间的共享也是问题。一般有两种打包方式：</p>
<pre><code>1. 子应用独立打包，模块解耦了，但公共的依赖不易维护处理
2. 整体应用一起打包，能解决公共依赖；但庞大的多个项目又使打包变慢，后续也不好扩展
</code></pre><p><strong>Webpack 5.x 实现了全新的解决方案</strong></p>
<p>这个方案是直接将一个应用的 bundle，应用于另一个应用，动态分发 runtime 子模块给其他应用</p>
<p>使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// other webpack configs...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">      <span class="comment">// 1. name 当前应用名称，需要全局唯一</span></span><br><span class="line">      name: <span class="string">"app_one_remote"</span>,</span><br><span class="line">      <span class="comment">// 2. remotes 可以将其他项目的 name 映射到当前项目中</span></span><br><span class="line">      remotes: &#123;</span><br><span class="line">        app_two: <span class="string">"app_two_remote"</span>,</span><br><span class="line">        app_three: <span class="string">"app_three_remote"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 3. exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用</span></span><br><span class="line">      exposes: &#123;</span><br><span class="line">        AppContainer: <span class="string">"./src/App"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 4. shared可以让远程加载的模块对应依赖改为使用本地项目的 React或ReactDOM。</span></span><br><span class="line">      shared: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>, <span class="string">"react-router-dom"</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./public/index.html"</span>,</span><br><span class="line">      chunks: [<span class="string">"main"</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如设置了 <code>remotes: { app_two: &quot;app_two_remote&quot; }</code>，在代码中就可以直接利用以下方式直接从对方应用调用模块:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Search &#125; <span class="keyword">from</span> <span class="string">"app_two/Search"</span>;</span><br><span class="line">app_two/Search来自于app_two 的配置:</span><br><span class="line"></span><br><span class="line"><span class="comment">// app_two的webpack 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">      name: <span class="string">"app_two"</span>,</span><br><span class="line">      library: &#123; <span class="attr">type</span>: <span class="string">"var"</span>, <span class="attr">name</span>: <span class="string">"app_two"</span> &#125;,</span><br><span class="line">      filename: <span class="string">"remoteEntry.js"</span>,</span><br><span class="line">      exposes: &#123;</span><br><span class="line">        Search: <span class="string">"./src/Search"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      shared: [<span class="string">"react"</span>, <span class="string">"react-dom"</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正是因为 Search 在 exposes 被导出，我们因此可以使用 <code>[name]/[exposes_name]</code> 这个模块，这个模块对于被引用应用来说是一个本地模块。</p>
<p>更多请参考官网 <a href="https://webpack.js.org/concepts/module-federation/#root" target="_blank" rel="noopener">Module Federation</a></p>
<p>参考链接：</p>
<p><a href="https://juejin.cn/post/6844904093463347208" target="_blank" rel="noopener">带你深度解锁Webpack系列(优化篇)</a></p>
<p><a href="https://webpack.wuhaolin.cn/" target="_blank" rel="noopener">深入浅出 Webpack</a></p>
<p><a href="https://juejin.cn/post/6844904169405415432#heading-3" target="_blank" rel="noopener">Webpack5 上手测评</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue-js/" rel="tag"># vue.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/20/浏览器缓存机制/" rel="next" title="浏览器缓存机制">
                <i class="fa fa-chevron-left"></i> 浏览器缓存机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/09/一些需要注意的js输出问题整理/" rel="prev" title="一些需要注意的js输出问题整理">
                一些需要注意的js输出问题整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/headPhoto.jpg" alt="cchroot">
            
              <p class="site-author-name" itemprop="name">cchroot</p>
              <p class="site-description motion-element" itemprop="description">Your bloom is the reason of the breeze</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">158</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/cchroot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/599eee90518825242238db1d" target="_blank" title="Juejin">
                      
                        <i class="fa fa-fw fa-angle-double-down"></i>Juejin</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://leetcode-cn.com/u/cchroot-liu/" target="_blank" title="LeetCode">
                      
                        <i class="fa fa-fw fa-skype"></i>LeetCode</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#优化方式总览"><span class="nav-number">1.</span> <span class="nav-text">优化方式总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加快-Webpack-构建速度-打包速度"><span class="nav-number">2.</span> <span class="nav-text">加快 Webpack 构建速度(打包速度)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-speed-measure-webpack-plugin-插件测量打包速度"><span class="nav-number">2.1.</span> <span class="nav-text">使用 speed-measure-webpack-plugin 插件测量打包速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-缩小文件的搜索范围-配置include-exclude-resolve-modules-resolve-mainFields-alias-noParse-extensions"><span class="nav-number">2.2.</span> <span class="nav-text">1.缩小文件的搜索范围(配置include/exclude resolve.modules resolve.mainFields alias noParse extensions)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exclude-include"><span class="nav-number">2.2.1.</span> <span class="nav-text">exclude/include</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化-resolve-modules-配置"><span class="nav-number">2.2.2.</span> <span class="nav-text">优化 resolve.modules 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化-resolve-mainFields-配置"><span class="nav-number">2.2.3.</span> <span class="nav-text">优化 resolve.mainFields 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resolve-alias"><span class="nav-number">2.2.4.</span> <span class="nav-text">resolve.alias</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#noParse"><span class="nav-number">2.2.5.</span> <span class="nav-text">noParse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resolve-extensions"><span class="nav-number">2.2.6.</span> <span class="nav-text">resolve.extensions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用-cache-loader，将结果缓存中磁盘中"><span class="nav-number">2.3.</span> <span class="nav-text">2.使用 cache-loader，将结果缓存中磁盘中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-使用-happypack-开启多进程打包"><span class="nav-number">2.4.</span> <span class="nav-text">3.使用 happypack 开启多进程打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-thread-loader"><span class="nav-number">2.5.</span> <span class="nav-text">4.thread-loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-使用-hard-source-webpack-plugin-为模块提供中间缓存"><span class="nav-number">2.6.</span> <span class="nav-text">5.使用 hard-source-webpack-plugin 为模块提供中间缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-使用-IgnorePlugin-忽略第三方包指定目录"><span class="nav-number">2.7.</span> <span class="nav-text">6.使用 IgnorePlugin 忽略第三方包指定目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-关于使用-webpack-parallel-uglify-plugin-增强代码压缩"><span class="nav-number">2.8.</span> <span class="nav-text">7.关于使用 webpack-parallel-uglify-plugin 增强代码压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#减少打包文件体积"><span class="nav-number">3.</span> <span class="nav-text">减少打包文件体积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引入-webpack-bundle-analyzer-分析打包后的文件"><span class="nav-number">3.1.</span> <span class="nav-text">引入 webpack-bundle-analyzer 分析打包后的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用-DllPlugin（动态链接库）将-bundles-拆分"><span class="nav-number">3.2.</span> <span class="nav-text">2.使用 DllPlugin（动态链接库）将 bundles 拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-使用-optimization-splitChunks-配置抽离公共代码"><span class="nav-number">3.3.</span> <span class="nav-text">3.使用 optimization.splitChunks 配置抽离公共代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-使用-IgnorePlugin-忽略第三方包指定目录，例如-moment-的本地语言包（重复）"><span class="nav-number">3.4.</span> <span class="nav-text">4.使用 IgnorePlugin 忽略第三方包指定目录，例如 moment 的本地语言包（重复）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-使用-url-loader-和-image-webpack-loader-对图片进行转化和压缩处理"><span class="nav-number">3.5.</span> <span class="nav-text">5.使用 url-loader 和 image-webpack-loader 对图片进行转化和压缩处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-优化-source-map"><span class="nav-number">3.6.</span> <span class="nav-text">6.优化 source map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-按需加载，"><span class="nav-number">3.7.</span> <span class="nav-text">7.按需加载，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-webpack4-x-后版本自身的优化："><span class="nav-number">3.8.</span> <span class="nav-text">8. webpack4.x 后版本自身的优化：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tree-Shaking"><span class="nav-number">3.8.1.</span> <span class="nav-text">Tree Shaking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scope-hosting-作用域提升，变量提升，可以减少一些变量声明"><span class="nav-number">3.8.2.</span> <span class="nav-text">scope hosting 作用域提升，变量提升，可以减少一些变量声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#babel-配置的优化"><span class="nav-number">3.8.3.</span> <span class="nav-text">babel 配置的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于-webpack-5-x"><span class="nav-number">4.</span> <span class="nav-text">关于 webpack 5.x</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-剔除npm包里面针对Node-js模块自动引用的Polyfills"><span class="nav-number">4.1.</span> <span class="nav-text">1.剔除npm包里面针对Node.js模块自动引用的Polyfills</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-长期缓存优化"><span class="nav-number">4.2.</span> <span class="nav-text">2.长期缓存优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-持久缓存优化"><span class="nav-number">4.3.</span> <span class="nav-text">3.持久缓存优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-更好的Tree-Shacking-构建优化"><span class="nav-number">4.4.</span> <span class="nav-text">4.更好的Tree Shacking(构建优化)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Module-Federation-模板联邦"><span class="nav-number">4.5.</span> <span class="nav-text">5.Module Federation(模板联邦)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cchroot</span>

  
</div>


  <div class="powered-by">个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
